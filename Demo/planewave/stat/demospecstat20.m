%  DEMOSPECSTAT20 - Light scattering of coupled nanospheres using nonlocality.
%    For two coupled metallic nanospheres and an incoming plane wave, this
%    program computes the scattering cross section for different light
%    wavelengths within the quasistatic approximation using a nonlocal
%    dielectric function.
%
%  Runtime on my computer:  90 sec.

%  We use the model of the Pendry group, Yu Luo et al., PRL 111, 093901
%  (2013), where a hydrodynamic description of the metal electrons is
%  mapped onto an effective model.  Here, the metal is described in terms
%  of a local Drude-type dielectric function, and the nonlocal effects are
%  emulated by a thin, artificial cover layer with a given local
%  permittivity.

%%  initialization
%  options for BEM simulation
%    for retarded simulations set 'sim' to 'ret'
op = bemoptions( 'sim', 'stat', 'waitbar', 1, 'interp', 'curv' );
%  For the thin artificial cover layer, we have to integrate over two close
%  boundary elements.  The refined integration over these elements, which
%  is performed in the function REFUN passed to the BEM solver, is done
%  using polar coordinates.  It is thus a good idea to increase the number
%  of integration points for polar integration and integration of neighbour
%  elements.
op = bemoptions( op, 'npol', 20, 'refine', 3 );

%  thickness of artificial layer
d = 0.05;
%  longitudinal plasmon wavenumber, see Yu Luo et al., PRL 111, 093901 (2013).
units;
ql = @( w ) 2 * pi * sqrt( 3.3 ^ 2 - w .* ( w + 1i * 0.165 ) ) / ( 0.0036 * eV2nm );
%  table of dielectric functions
%    eps1 - dielectric constant of embedding medium
%    eps2 - Drude-type dielectric function representative for gold
%    eps3 - artificial permittivity according to description of Luo et al.
eps1 = epsconst( 1 );
eps2 = epsfun( @( w ) 1 - 3.3 ^ 2 ./ ( w .* ( w + 1i * 0.165 ) ), 'eV' );
eps3 = epsfun( @( enei ) eps2( enei ) .* eps1( enei ) ./  ...
            ( eps2( enei ) - eps1( enei ) ) .* ql( eV2nm ./ enei ) * d );

epstab = { eps1, eps2, eps3, eps2, eps3 };

%  diameter of sphere, gap distance
diameter = 10;
gap = 0.50;
%  initialize spheres
%    The inner sphere, which separates the Drude metal from the artificial
%    cover layer, is generated by shifting all vertices by a distance D
%    along the directions of the outer surface normals. 

%  angles for sphere discretization
phi = linspace( 0, 2 * pi, 20 );
theta = pi * linspace( 0, 1, 25 ) .^ 2;
%  initialize lower spheres
plo2 = trispheresegment( phi, theta, diameter - 2 * d );
plo2 = shift( plo2, [ 0, 0, - 0.5 * ( diameter - 2 * d + gap ) ] );
plo1 = coverlayer.shift( plo2, d );
%  initialize upper spheres
pup2 = flip( plo2, 3 );
pup1 = coverlayer.shift( pup2, d );
%  make COMPARTICLE object for local and nonlocal model
p1 = comparticle( epstab, { plo1, pup1 }, [ 2, 1; 4, 1 ], 1, 2, op );
p2 = comparticle( epstab, { plo1, plo2, pup1, pup2 },  ...
                        [ 3, 1; 2, 3; 5, 1; 4, 5 ], 1, 2, 3, 4, op );

%%  BEM simulation
%  set up BEM solver2
%    We have to be careful about the Green function refinement for
%    neighbour boundary elements of the cover layer.  This integration is
%    performed in polar coordinates (check for convergence of NPOL) in the
%    function coverlayer.refine passed to the BEM solver.  [ 1, 2; 3, 4 ]
%    indicate the two cover layer boundaries, where one layer is produced
%    through the coverlayer.shift function.
bem1 = bemsolver( p1, op );
bem2 = bemsolver( p2, op, 'refun', coverlayer.refine( p2, [ 1, 2; 3, 4 ] ) );

%  plane wave excitation
exc = planewave( [ 1, 0, 0; 0, 0, 1 ], [ 0, 0, 1; 1, 0, 0 ], op );
%  light wavelength in vacuum
enei = linspace( 400, 1200, 60 );
%  allocate scattering and extinction cross sections
[ sca1, ext1, sca2, ext2 ] = deal( zeros( length( enei ), 2 ) );

multiWaitbar( 'BEM solver', 0, 'Color', 'g', 'CanCancel', 'on' );
%  loop over wavelengths
for ien = 1 : length( enei )
  %  surface charge
  sig1 = bem1 \ exc( p1, enei( ien ) );
  sig2 = bem2 \ exc( p2, enei( ien ) );
  %  scattering and extinction cross sections
  sca1( ien, : ) = exc.sca( sig1 );
  ext1( ien, : ) = exc.ext( sig1 );
  sca2( ien, : ) = exc.sca( sig2 );
  ext2( ien, : ) = exc.ext( sig2 );  
  
  multiWaitbar( 'BEM solver', ien / numel( enei ) );
end
%  close waitbar
multiWaitbar( 'CloseAll' );

%%  final plot
plot( enei, sca1( :, 2 ), 'o-'  );  hold on;
plot( enei, sca2( :, 2 ), 's-'  );  

xlabel( 'Wavelength (nm)' );
ylabel( 'Scattering cross section (nm^2)' );

legend( 'local', 'non-local' );
